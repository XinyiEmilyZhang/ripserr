---
title: Calculating persistent homology in R with ripserr
authors:
  - name: Raoul R. Wadhwa
    department: Cleveland Clinic Lerner College of Medicine
    affiliation: Case Western Reserve University
    location: Cleveland, OH 44195, United States
    email: raoul.wadhwa@case.edu
  - name: Matthew Piekenbrock, MS
    department: Computational Mathematics, Science, \& Engineering
    affiliation: Michigan State University
    location: East Lansing, MI 48824, United States
    email: matt.piekenbrock@gmail.com
  - name: Jacob G. Scott, MD, DPhil
    department: Translational Hematology \& Oncology Research
    affiliation: Lerner Research Institute, Cleveland Clinic
    location: Cleveland, OH 44195, United States
    email: ScottJ10@ccf.org
abstract: |
  Enter the text of your abstract here.
keywords:
  - persistent homology
  - topological data analysis
  - simplicial complex
  - R programming language
  - Ripser
bibliography: references.bib
output: rticles::arxiv_article
---

# Introduction

Calculating persistent homology presents a computationally expensive challenge, particularly for large and high-dimensional datasets.
Ripser, a C++ library, addresses this obstacle and significantly reduces processing time and memory usage compared to contemporary persistent homology engines [@ripser].
Although Ripser calculates persistent homology of a Vietoris-Rips complex, other libraries have built upon its foundation [@cubicalripser; @flagser; @lockfreeripser; @ripserpp].
With the increasing popularity of persistent homology, wrapping Ripser and related engines in the R programming language [@rlang] would permit easier incorporation into data analysis and machine learning pipelines.
Here, we introduce `ripserr`, an R package that wraps the Ripser and Cubical Ripser C++ libraries, allowing efficient persistent homology computation of Vieoris-Rips and cubical complexes.

# `PHom` S3 class

When incorporating persistent homology in R pipelines, we must consider the best container to hold persistence data.
`ripserr` uses the `PHom` (portmanteau of persistent homology) S3 class to manage persistence data.
Note that more complex forms of persistence (e.g. extended persistence [@ext-persist]) are not discussed.

At its core, the `PHom` class simply encompasses a data frame storing persistence feature details.
Each data frame row represents a single feature and each column represents a single feature property.
Structurally, the data frame within a `PHom` object has three columns named `"dimension"`, `"birth"`, and `"death"` (in that order) of class `integer`, `numeric`, and `numeric`, respectively.
Although `PHom`-specific S3 generic methods have been implemented, users may also benefit by using `data.frame`-specific S3 generic methods; for this reason, `PHom` objects have class `PHom` and `data.frame`.

To get a better intuition for `PHom` objects, the following code block demonstrates the class's basic functionality.
We first create a data frame containing synthetic persistence data, convert it to a `PHom` instance, then explore how to work with its new form.

```{r basic-ex, error=TRUE}
# setup
library("ripserr")

# synthetic persistence data
df <- data.frame(dimension = c(rep(0, 2), rep(1, 3), rep(2, 1)),
                 birth = rnorm(6),
                 death = rnorm(6, mean = 15))

# print synthetic persistence data
print(df)

# convert to PHom
df_phom <- PHom(df)

# print
print(df_phom)

# print feature details of PHom object
print.data.frame(df_phom)

# can convert with PHom or as.PHom
df_phom2 <- as.PHom(df)
all.equal(df_phom, df_phom2)

# adjust synthetic data with invalid persistence data (death < birth)
df$death[1] <- df$birth[1] - 0.1
print(df)

# error when converting to PHom object
PHom(df)
```

# Persistent homology of a Vietoris-Rips complex

## overview and basic parameters

## generic methods

## prime fields

## use case

# Persistent homology of a cubical complex

## overview and basic parameters

## generic methods

## size limitations

## use case

# Discussion/Conclusions

## comparison to TDAstats and TDA

## future directions

# Acknowledgments

The authors thank Jason Cory Brunson, PhD for advice regarding `ripserr` package design.

# References
